"use strict";(()=>{async function drawScareness(text){const textureDict="timerbars";if(!HasStreamedTextureDictLoaded(textureDict)){RequestStreamedTextureDict(textureDict,true);while(!HasStreamedTextureDictLoaded(textureDict)){await Delay(10)}}const safeZone=(1-GetSafeZoneSize())*.5;const baseX=.918-safeZone;const baseY=.984-safeZone;DrawSprite(textureDict,"all_black_bg",baseX,baseY,.165,.035,0,255,255,255,160);BeginTextCommandDisplayText("CELL_EMAIL_BCON");SetTextFont(0);SetTextScale(.425,.425);SetTextColour(255,255,255,255);SetTextRightJustify(true);SetTextWrap(0,baseX+.0785);AddTextComponentSubstringPlayerName(text);EndTextCommandDisplayText(baseX+.0785,baseY-.0165)}function drawProgress(value){const screenCenterX=.5;const screenBottomY=.96;const width=.12;const clampedValue=Math.max(0,Math.min(value,100));const progressRatio=clampedValue/100;const progressWidth=width*progressRatio;const progressOffsetX=screenCenterX-width/2+progressWidth/2;DrawRect(screenCenterX,screenBottomY,width,.015,0,0,0,180);DrawRect(progressOffsetX,screenBottomY,progressWidth,.009,220,50,50,255)}function Delay(ms){return new Promise(resolve=>setTimeout(resolve,ms))}async function loadAnimDict(dict){if(!DoesAnimDictExist(dict)){return}RequestAnimDict(dict);while(!HasAnimDictLoaded(dict)){await Delay(10)}}async function playAnimation(entity,dict,lib,flag){if(!IsEntityPlayingAnim(entity,dict,lib,flag??49)){await loadAnimDict(dict);TaskPlayAnim(entity,dict,lib,2,-1,-1,flag??49,0,false,false,false)}}function isAimingMeleeAtTarget(ped,target2){if(!DoesEntityExist(target2)){console.error("Ingen giltig target entity angavs");return false}const pedCoords=GetEntityCoords(ped,true);const targetCoords=GetEntityCoords(target2,true);const dist=Vdist(pedCoords[0],pedCoords[1],pedCoords[2],targetCoords[0],targetCoords[1],targetCoords[2]);if(dist>3)return false;const camRot=GetGameplayCamRot(2);const pitch=camRot[0]*(Math.PI/180);const yaw=camRot[2]*(Math.PI/180);const camForward=[Math.cos(pitch)*Math.sin(yaw),Math.cos(pitch)*Math.cos(yaw),Math.sin(pitch)];const dirToTarget=[targetCoords[0]-pedCoords[0],targetCoords[1]-pedCoords[1],targetCoords[2]-pedCoords[2]];const length=Math.sqrt(dirToTarget[0]**2+dirToTarget[1]**2+dirToTarget[2]**2);if(length===0)return false;const normDirToTarget=[dirToTarget[0]/length,dirToTarget[1]/length,dirToTarget[2]/length];const dot=camForward[0]*normDirToTarget[0]+camForward[1]*normDirToTarget[1]+camForward[2]*normDirToTarget[2];const angleDeg=Math.acos(dot)*(180/Math.PI);const maxAngle=60;return angleDeg<=maxAngle}function isEntityRobbed(entity){if(entity===-1)return;if(!DoesEntityExist(entity)){console.warn("Peden existerar inte?");return}if(!NetworkGetEntityIsNetworked(entity)){NetworkRegisterEntityAsNetworked(entity)}return Entity(entity).state.robbed}function sendNotify(text,type){TriggerEvent("core:client:notification",{title:"Olaglig aktivitet",text,type})}var weapons={[GetHashKey("WEAPON_KNIFE")]:{male:50,female:85,multiplier:.7,divider:2,melee:true},[GetHashKey("WEAPON_PISTOL")]:{male:92,female:100,multiplier:1.6,divider:1,melee:false}};var isActive=false;var target=-1;var lastTime=0;function isArmed(){const ped=PlayerPedId();const[success,weaponHash]=GetCurrentPedWeapon(ped,false);return success&&weaponHash in weapons}async function getGunData(){const[success,weaponHash]=GetCurrentPedWeapon(PlayerPedId(),false);if(!success||!(weaponHash in weapons)){console.warn("Inget giltigt vapen");return null}return weapons[weaponHash]}async function finish(){ClearPedTasksImmediately(target);await Delay(150);playAnimation(target,"mp_common","givetake1_a");emitNet("npc_robbery:server:giveReward");await Delay(1e3);ClearPedTasksImmediately(target);FreezeEntityPosition(target,false);SetBlockingOfNonTemporaryEvents(target,false);SetPedFleeAttributes(target,0,false);TaskSmartFleePed(target,PlayerPedId(),100,-1,false,false);setTimeout(()=>{DeleteEntity(target)},7500);target=0;isActive=false}function notScared(){console.log("Inte rädd");if(!target||!DoesEntityExist(target)){console.error("Peden finns inte?");return}ClearPedTasksImmediately(target);FreezeEntityPosition(target,false);const luck=Math.floor(Math.random()*100)+1;const targetLuck=IsPedMale(target)?50:85;if(luck<=targetLuck){SetPedFleeAttributes(target,0,true);SetBlockingOfNonTemporaryEvents(target,true);SetPedCanEvasiveDive(target,false);SetPedAsEnemy(target,true);SetPedCombatAttributes(target,0,true);SetPedCombatAttributes(target,1,true);SetPedCombatAttributes(target,5,true);SetPedCombatAttributes(target,17,true);SetPedCombatAttributes(target,46,true);TaskCombatPed(target,PlayerPedId(),0,16)}else{SetBlockingOfNonTemporaryEvents(target,false);SetPedFleeAttributes(target,0,false);TaskSmartFleePed(target,PlayerPedId(),100,-1,false,false);setTimeout(()=>{DeleteEntity(target)},7500)}target=0;isActive=false}async function startRobbing(entity){if(isActive)return;if(!DoesEntityExist(entity)||!IsEntityAPed(entity))return;const time=GetGameTimer();if(time-lastTime<6e4){sendNotify("Lugna ner dig lite först..","error");isActive=false;return}lastTime=time;target=entity;const weaponData=await getGunData();if(!weaponData){console.log("Inget giltigt vapen framme");Entity(entity).state.set("robbed",false,true);return}const luck=Math.floor(Math.random()*100)+1;const targetLuck=IsPedMale(target)?weaponData.male:weaponData.female;if(luck>targetLuck){notScared();return}isActive=true;let progress=0;let scareness=5;FreezeEntityPosition(target,true);ClearPedTasksImmediately(target);SetBlockingOfNonTemporaryEvents(target,true);SetPedFleeAttributes(target,0,false);SetPedCombatAttributes(target,46,true);SetPedSeeingRange(target,0);SetPedHearingRange(target,0);let isAimingAtTarget=false;const interval=setInterval(()=>{if(!isActive)return clearInterval(interval);playAnimation(target,"missminuteman_1ig_2","handsup_base");if(!isArmed()){notScared();clearInterval(interval);return}if(!DoesEntityExist(target)||IsPedDeadOrDying(target,false)){isActive=false;sendNotify("Personen är död..","error");clearInterval(interval);return}if(scareness<.5){notScared();clearInterval(interval);return}if(isAimingAtTarget){const df=.4*weaponData.multiplier;scareness+=df;if(scareness>16){scareness=16}}else{const df=.5/weaponData.divider;scareness-=df}const amountToAdd=scareness>=15?.8:scareness<1.5?.45:.15;progress+=amountToAdd;if(progress>=100){finish();clearInterval(interval);return}},150);const tick=setTick(()=>{if(!isActive)return clearTick(tick);if(weaponData.melee){const success=isAimingMeleeAtTarget(PlayerPedId(),target);if(success){isAimingAtTarget=true}else{isAimingAtTarget=false}}else{const[asuccess,entity2]=GetEntityPlayerIsFreeAimingAt(PlayerId());if(asuccess&&DoesEntityExist(entity2)&&IsEntityAPed(entity2)&&entity2===target){isAimingAtTarget=true}else{isAimingAtTarget=false}}TaskTurnPedToFaceEntity(target,PlayerPedId(),900);SetFacialIdleAnimOverride(target,"mood_stressed_1","");drawScareness(`${scareness>=15?"Personen är livrädd":scareness<2.5?"Personen är oberörd":"Personen är nervös"}`);drawProgress(progress)})}setTick(()=>{const ped=PlayerPedId();const[x,y,z]=GetEntityCoords(ped,false);if(!isActive&&isArmed()){const[success,entity]=GetEntityPlayerIsFreeAimingAt(PlayerId());if(success&&DoesEntityExist(entity)&&IsEntityAPed(entity)&&!IsPedDeadOrDying(entity,false)&&!IsPedInAnyVehicle(entity,false)){const[ex,ey,ez]=GetEntityCoords(entity,false);const dist=Vdist(x,y,z,ex,ey,ez);if(dist<12.5&&!isEntityRobbed(entity)){Entity(entity).state.set("robbed",true,true);startRobbing(entity)}}}});})();
